//
//  MeasurementEditorV.swift
//  Map Map
//
//  Created by Ben Roberts on 12/15/23.
//

import Bottom_Drawer
import MapKit
import SwiftUI

struct MeasurementEditorV: View {
    /// Information about the background map being plotted on top of.
    @Environment(BackgroundMapDetailsM.self) var backgroundMapDetails
    /// All available MapMaps.
    @FetchRequest(sortDescriptors: []) var mapMaps: FetchedResults<MapMap>
    /// Measurement to edit.
    @ObservedObject var measurement: FetchedResults<MapMeasurement>.Element
    /// Managed object context the measurement is stored in.
    @Environment(\.managedObjectContext) private var moc
    /// Real-world distance between the start and end points.
    @State private var distance: Measurement<UnitLength> = Measurement(value: .zero, unit: .meters)
    /// Screen-space position of the measuring point.
    @State private var startingPos: CGSize = .zero
    /// Screen-space position of the ending point.
    @State private var endingPos: CGSize = .zero
    /// Track if dragging is currently happening.
    @State private var isDragging: Bool = false
    /// Map proxy generated by a MapReader.
    var mapContext: MapProxy
    
    /// Basic orientation and positioning for a line
    enum Orientation {
        case leftVertical
        case rightVertical
        case topHorizontal
        case bottomHorizontal
    }
    
    /// Drag gesture for creating a line from scratch.
    var drawGesture: some Gesture {
        DragGesture(coordinateSpace: .global)
            .onChanged { update in
                if !isDragging {
                    startingPos = CGSize(cgPoint: update.startLocation)
                    isDragging = true
                }
                endingPos = CGSize(cgPoint: update.location)
            }
            .onEnded { _ in
                isDragging = false
            }
    }
    
    var body: some View {
        ZStack {
            Color.black
                .opacity(0.5)
                .ignoresSafeArea()
                .gesture(drawGesture)
            if endingPos != startingPos {
                ZStack {
                    Line(startingPos: startingPos, endingPos: endingPos)
                        .stroke(style: StrokeStyle(lineWidth: 5, lineCap: .round))
                        .shadow(radius: 2)
                        .lineLabel(startingPos: CGPoint(size: startingPos), endingPos: CGPoint(size: endingPos), distance: distance)
                    HandleV(position: $startingPos)
                    HandleV(position: $endingPos)
                }
                .ignoresSafeArea()
            }
            
            BottomDrawer(verticalDetents: [.content], horizontalDetents: [.center], shortCardSize: 350) { _ in
                VStack {
                    HStack {
                        // Done button
                        Button {
                            guard let startingCoord = mapContext.convert(CGPoint(size: startingPos), from: .global),
                                  let endingCoord = mapContext.convert(CGPoint(size: endingPos), from: .global)
                            else { return }
                            measurement.startingCoordinates = startingCoord
                            measurement.endingCoordinates = endingCoord
                            if let mapMap = MeasurementEditorV.mapMeasurementOverMapMap(
                                measurement,
                                backgroundMapDetails: backgroundMapDetails,
                                mapMaps: mapMaps,
                                mapContext: mapContext
                            ) { mapMap.addToMeasurements(measurement) }
                            measurement.isEditing = false
                            try? moc.save()
                        } label: {
                            Text("Done")
                                .bigButton(backgroundColor: .blue.opacity(isValidMeasurement() ? 1 : 0.5))
                        }
                        .disabled(!isValidMeasurement())
                        
                        // Cancel button
                        Button(action: {
                            moc.reset()
                        }, label: {
                            Text("Cancel")
                                .bigButton(backgroundColor: .gray)
                        })
                        
                        // Delete button
                        Button( action: {
                            moc.delete(measurement)
                            try? moc.save()
                        }, label: {
                            Text("Delete")
                                .bigButton(backgroundColor: .red)
                        })
                    }
                }
            }
        }
        .onChange(of: startingPos) { calculateDistance() }
        .onChange(of: endingPos) { calculateDistance() }
    }
    
    /// Calculate the real-world distance based on screen-space positions.
    private func calculateDistance() {
        guard let startingCoord = mapContext.convert(CGPoint(size: startingPos), from: .global),
              let endingCoord = mapContext.convert(CGPoint(size: endingPos), from: .global)
        else { return }
        let startLoc = CLLocation(latitude: startingCoord.latitude, longitude: startingCoord.longitude)
        let endLoc = CLLocation(latitude: endingCoord.latitude, longitude: endingCoord.longitude)
        self.distance = Measurement(value: endLoc.distance(from: startLoc), unit: .meters)
    }
    
    /// Check if the current measurement is valid.
    /// - Returns: True if valid, False if invalid.
    private func isValidMeasurement() -> Bool {
        if startingPos == endingPos { return false }
        return true
    }
    
    /// Checks for `MapMeasurement`s overlapping any MapMap.
    /// - Parameters:
    ///   - measurement: Measurement to check against.
    ///   - backgroundMapDetails: Details of the background map being plotted on.
    ///   - mapMaps: MapMaps to check.
    ///   - mapContext: A `MapProxy` that is generated by a `MapReader` to allow for mapping of lat/long coordinates to screen-space.
    /// - Returns: A single MapMap which overlaps the MapMeasurement
    public static func mapMeasurementOverMapMap(
        _ measurement: MapMeasurement,
        backgroundMapDetails: BackgroundMapDetailsM,
        mapMaps: FetchedResults<MapMap>,
        mapContext: MapProxy
    ) -> MapMap? {
        guard let startingPos = mapContext.convert(measurement.startingCoordinates, to: .global),
              let endingPos = mapContext.convert(measurement.endingCoordinates, to: .global)
        else { return nil }
        for mapMap in mapMaps {
            guard let mapMapConvexHull = BackgroundMap.generateMapMapRotatedConvexHull(
                mapMap: mapMap,
                backgroundMapDetails: backgroundMapDetails,
                mapContext: mapContext
            )
            else { continue }
            if mapMapConvexHull.contains(startingPos) || mapMapConvexHull.contains(endingPos) { return mapMap }
        }
        return nil
    }
}
