//
//  BackgroundMapPointsV.swift
//  Map Map
//
//  Created by Ben Roberts on 11/20/23.
//

import MapKit
import SwiftUI

/// Points that cannot be Annotations on the background map.
struct BackgroundMapPointsV: View {
    /// Information about the background map.
    @Environment(BackgroundMapDetailsM.self) private var backgroundMapDetails
    /// All available markers.
    @FetchRequest(sortDescriptors: []) private var markers: FetchedResults<Marker>
    /// All available measurements.
    @FetchRequest(sortDescriptors: []) private var measurements: FetchedResults<MapMeasurement>
    /// GPS user location.
    @State private var locationsHandler = LocationsHandler.shared
    /// The user's location in screen-space
    @State private var ssUserLocation: CGPoint?
    /// Size of the parent view.
    let screenSize: CGSize
    /// Marker icon size.
    static let iconSize: CGFloat = 30
    /// User location icon size.
    private let userLocationSize: CGFloat = 24
    /// Offset marker slightly for correct alignment.
    private let markerOffset: CGFloat = -2
    /// Map context generated by a map reader
    let mapContext: MapProxy
    
    var body: some View {
        GeometryReader { _ in
            ForEach(measurements) { measurement in
                if let startingPos = mapContext.convert(measurement.startingCoordinates, to: .global),
                   let endingPos = mapContext.convert(measurement.endingCoordinates, to: .global) {
                    let distance = sqrt(pow(abs(startingPos.x - endingPos.x), 2) + pow(abs(startingPos.y - endingPos.y), 2))
                    let rotation = atan2(startingPos.y - endingPos.y, startingPos.x - endingPos.x)
                    Button {
                        backgroundMapDetails.moveMapCameraTo(measurement: measurement)
                    } label: {
                        Capsule()
                            .frame(
                                width: distance,
                                height: 5
                            )
                            .padding(25)
                            .foregroundStyle(.white)
                            .shadow(radius: 2)
                    }
                    .rotationEffect(Angle(radians: rotation))
                    .contextMenu {
                        MapMeasurementContextMenuV(measurement: measurement)
                    } preview: {
                        Color.white
                            .frame(
                                width: distance,
                                height: 5
                            )
                    }
                    .position(
                        x: (startingPos.x + endingPos.x) / 2,
                        y: (startingPos.y + endingPos.y) / 2
                    )
                    .lineLabel(
                        startingPos: startingPos,
                        endingPos: endingPos,
                        distance: measurement.distance
                    )
                }
            }
            
            ForEach(markers) { marker in
                if let position = mapContext.convert(marker.coordinates, to: .global), !marker.isEditing && marker.shown {
                    ZStack {
                        Button {
                            backgroundMapDetails.moveMapCameraTo(marker: marker)
                        } label: {
                            MarkerV(marker: marker)
                                .rotationEffect(
                                    backgroundMapDetails.rotation -
                                    Angle(degrees: marker.lockRotationAngleDouble ?? backgroundMapDetails.rotation.degrees)
                                )
                                .offset(y: markerOffset)
                        }
                        .contextMenu { MarkerContextMenuV(marker: marker) }
                        .frame(width: BackgroundMapPointsV.iconSize, height: BackgroundMapPointsV.iconSize)
                        if let markerName = marker.name, isOverMarker(marker) {
                            Text(markerName)
                                .mapLabel()
                                .foregroundStyle(.white)
                                .allowsHitTesting(false)
                                .offset(y: BackgroundMapPointsV.iconSize)
                        }
                    }
                    .position(position)
                }
            }
            VStack {
                let userLocation = CLLocationCoordinate2D(
                    latitude: locationsHandler.lastLocation.coordinate.latitude,
                    longitude: locationsHandler.lastLocation.coordinate.longitude
                )
                if let screenSpaceUserLocation = mapContext.convert(userLocation, to: .global) {
                    MapUserIcon()
                        .frame(width: userLocationSize, height: userLocationSize)
                        .position(screenSpaceUserLocation)
                }
                else { EmptyView() }
            }
            .ignoresSafeArea()
            .onAppear { locationsHandler.startLocationTracking() }
            .onDisappear { locationsHandler.stopLocationTracking() }
            .onChange(of: locationsHandler.lastLocation) { _, update in
                let userCoords = CLLocationCoordinate2D(
                    latitude: update.coordinate.latitude,
                    longitude: update.coordinate.longitude
                )
                ssUserLocation = mapContext.convert(userCoords, to: .global)
            }
            .animation(.linear, value: ssUserLocation)
        }
    }
    
    func isOverMarker(_ marker: Marker) -> Bool {
        guard let markerPos = mapContext.convert(marker.coordinates, to: .global) else { return false }
        let xComponent = abs(markerPos.x - screenSize.width / 2)
        let yComponent = abs(markerPos.y - (screenSize.height / 2 - markerOffset))
        let distance = sqrt(pow(xComponent, 2) + pow(yComponent, 2))
        return distance < BackgroundMapPointsV.iconSize / 2
    }
}
