//
//  BackgroundMapPointsV.swift
//  Map Map
//
//  Created by Ben Roberts on 11/20/23.
//

import MapKit
import SwiftUI

/// Points that cannot be Annotations on the background map.
struct BackgroundMapPointsV: View {
    /// Information about the background map.
    @Environment(BackgroundMapDetailsM.self) private var backgroundMapDetails
    /// All available markers.
    @FetchRequest(sortDescriptors: []) private var markers: FetchedResults<Marker>
    /// All available measurements.
    @FetchRequest(sortDescriptors: []) private var measurements: FetchedResults<MapMeasurement>
    /// Screen space positions of Markers, MapMaps, and user location.
    @Environment(ScreenSpacePositionsM.self) private var screenSpacePositions
    /// Size of the parent view.
    let screenSize: CGSize
    /// Marker icon size.
    static let iconSize: CGFloat = 30
    /// User location icon size.
    private let userLocationSize: CGFloat = 24
    /// Offset marker slightly for correct alignment.
    private let markerOffset: CGFloat = -2
    /// Map context generated by a map reader
    let mapContext: MapProxy
    
    var body: some View {
        GeometryReader { _ in
            ForEach(measurements) { measurement in
                if let startingPos = mapContext.convert(measurement.startingCoordinates, to: .global),
                   let endingPos = mapContext.convert(measurement.endingCoordinates, to: .global) {
                    LabeledLineV(
                        startingPos: CGSize(cgPoint: startingPos),
                        endingPos: CGSize(cgPoint: endingPos),
                        distance: measurement.distance
                    )
                }
            }
        }
        ForEach(markers) { marker in
            if let position = screenSpacePositions[marker], !marker.isEditing && marker.shown {
                ZStack {
                    Button {
                        backgroundMapDetails.moveMapCameraTo(marker: marker)
                    } label: {
                        MarkerV(marker: marker)
                            .rotationEffect(
                                backgroundMapDetails.rotation -
                                Angle(degrees: marker.lockRotationAngleDouble ?? backgroundMapDetails.rotation.degrees)
                            )
                            .offset(y: markerOffset)
                    }
                    .contextMenu {
                        MarkerContextMenuV(marker: marker) {
                            screenSpacePositions.removeValue(forKey: marker)
                        }
                    }
                    .frame(width: BackgroundMapPointsV.iconSize, height: BackgroundMapPointsV.iconSize)
                    if let markerName = marker.name, isOverMarker(marker) {
                        Text(markerName)
                            .mapLabel()
                            .foregroundStyle(.white)
                            .allowsHitTesting(false)
                            .offset(y: BackgroundMapPointsV.iconSize)
                    }
                }
                .position(position)
            }
        }
        VStack {
            if let screenSpaceUserLocation = screenSpacePositions.userLocation {
                MapUserIcon()
                    .frame(width: userLocationSize, height: userLocationSize)
                    .position(screenSpaceUserLocation)
            }
            else { EmptyView() }
        }
        .ignoresSafeArea()
    }
    
    func isOverMarker(_ marker: Marker) -> Bool {
        guard let markerPos = screenSpacePositions[marker] else { return false }
        let xComponent = abs(markerPos.x - screenSize.width / 2)
        let yComponent = abs(markerPos.y - (screenSize.height / 2 - markerOffset))
        let distance = sqrt(pow(xComponent, 2) + pow(yComponent, 2))
        return distance < BackgroundMapPointsV.iconSize / 2
    }
}
